---
title: "[코딩인터뷰] Chapter1 배열과 문자열"
date: 2025-01-11 11:14:00 +09:00
categories: [스터디, 코딩인터뷰 완전분석]
tags:
  [
    코딩인터뷰 완전분석
  ]
---
> [1. 해시테이블](#해시테이블)   
> [2. ArrayList와 가변 크기 배열](#arraylist와-가변-크기-배열)  
> [3. 파이썬에서 문자열 연결과 join()의 효율성](#파이썬에서-문자열-연결과-join의-효율성)   
> [4. 면접 문제](#면접문제)  
>&ensp; [1.1 중복이 없는가](#11-중복이-없는가)  
>&ensp; [1.2 순열 확인](#12-순열-확인)  
>&ensp; [1.3 URL화](#13-url화)  
>&ensp; [1.4 회문 순열](#14-회문-순열)  


## 해시테이블
---

1. **해시테이블의 정의**:
    - 효율적인 탐색을 위한 자료구조로, 키(key)와 값(value)을 매핑한다.
    - 주어진 키에 대해 빠르게 값을 찾아낼 수 있다. 이를 위해 해시 함수를 이용해 키를 고유한 인덱스로 변환한다.
2. **구현 방법**:
    - 키를 해시 코드로 변환한 후, 배열의 길이로 나눈 나머지를 통해 배열의 인덱스를 계산한다.
    - 해시 함수로 계산된 인덱스에 데이터를 저장한다.
    - 동일한 인덱스에 여러 키가 매핑되는 경우는 연결 리스트를 사용해 출동을 관리한다.
3. **탐색 과정**:
    - 키에 해당하는 값은 연결 리스트에서 탐색하여 찾는다.
    - 최악의 경우(충돌이 자주 발생할 때), 탐색 시간은 O(N)이다.
    - 하지만 충돌을 최소화하도록 설계된 경우에는 평균적으로 O(1)의 탐색 시간이 소요된다.
        
        ![image.png](assets/img/post1_image1.png)

        
4. **다른 구현 방식**:
    - 균형 이진 탐색 트리(Balanced Binary Search Tree)를 사용하면 탐색 시간은 O(logN)이다.
        - 이 방법은 크기가 큰 배열을 미리 할당하지 않아도 되며, 적은 공간을 사용하는 장점이 있다
        - 또한 키의 접근을 특정 순서로 차례대로 할 수 있다.

결론적으로, 해시테이블은 효율적인 탐색을 제공하지만, 충돌이 발생할 경우 성능이 저하될 수 있다. 따라서 충돌을 줄이는 해시 함수 설계가 중요하다.

> ❓
> <span style="color: #495057 ; font-weight: bold;">딕셔너리랑 해시테이블은 뭐가 다른거지? </span>  
> 딕셔너리는 파이썬에서 최적화된 기능, 사용 편의성을 제공하는 자료형이다. 해시테이블이 자료구조의 개념적 구현이라면, 딕셔너리는 이를 실용적으로 활용할 수 있게 추상화된 도구이다. 
>- **해시테이블(Hash Table)**
    - 데이터를 저장하기 위한 **자료구조**이다.
    - 키를 해시 함수로 변환하여 값을 저장할 위치를 결정한다.
    - 구현 방식과 세부 동작(충돌 처리 등)은 사용자가 직접 설계하거나 구현해야 한다.
>- **딕셔너리(Dictionary)**
    - 파이썬의 **내장 자료형**으로, 키-값 쌍을 저장하는 **추상화된 데이터 구조**이다.
    - 내부적으로는 해시테이블을 사용하지만, 사용자는 세부 구현을 신경 쓰지 않아도 된다.     
>       ```python
        my_dict = {}
        my_dict['key'] = 'value'   # 삽입
        print(my_dict['key'])      # 검색
        del my_dict['key']         # 삭제
        ```
        


## ArrayList와 가변 크기 배열

---

1. **ArrayList와 가변 크기 배열의 작동 방식**

- ArrayList는 배열의 크기를 자동으로 조정하는 자료구조이다.
- 데이터가 추가될 때 배열의 크기가 가득 차면, 배열의 크기를 **두 배로 늘린 후** 기존 데이터를 새로운 배열로 복사한다.
- **고정 크기 배열의 문제점**
    - 배열 크기가 고정되어 있으면, 데이터를 추가하기 전에 배열 크기를 미리 지정해야 한다.
    - 데이터의 크기를 예측할 수 없거나 점진적으로 증가하는 경우, 크기를 미리 할당하는 것이 비효율적일 수 있다.
- **가변 크기 배열의 장점**
    - 데이터가 추가될 때 배열의 크기를 자동으로 조정하여 유연하게 작동한다.
    - 새로운 배열로 복사하는 작업이 일부 발생하더라도(배열의 상황에 따라 최악의 경우에는 O(N)이 소요될 수 있지만), 평균적인 삽입 시간은 O(1)을 유지한다.
        - 배열 크기가 두 배로 늘어날 때마다 복사해야 하는 원소의 개수를 보면 다음과 같다:
            
            크기 증가 1회: N/2개의 원소 복사
            크기 증가 2회: N/4개의 원소 복사
            크기 증가 3회: N/8개의 원소 복사
            ...
            복사해야 하는 총 원소 개수는 N/2+N/4+N/8+⋯+1이다.
            
            이 합계는 **기하급수적 수열**의 합이며, 결과적으로 N에 수렴한다.
            
            즉, N번의 삽입 작업 중에서 복사 작업은 한 번 발생하므로, 평균 삽입 시간은 O(1)로 계산된다.
            

## 파이썬에서 문자열 연결과 join()의 효율성

---

교재에서는 자바로 설명되어있지만 나는 파이썬을 쓰기때문에 파이썬으로 적용해서 설명하겠다. 

파이썬에서 문자열 연결 작업을 효율적으로 수행하기 위해 `join()` 메서드를 사용하는 것이 중요하다. 문자열은 불변 객체(immutable)이기 때문에 단순한 연결 작업이 반복되면 메모리와 시간이 낭비될 수 있다.

**1. 문제: 단순 문자열 연결의 비효율성**

아래 코드는 문자열 리스트를 순회하며 하나씩 이어붙이는 방식으로 동작한다.

```python
def join_words(words):
    sentence = ""
    for w in words:
        sentence += w
    return sentence
```

**문제점**

- 파이썬 문자열은 불변 객체이므로, `+=` 연산은 기존 문자열을 복사하고 새로운 문자열을 생성하는 과정을 거친다.
- 문자열의 길이가 이고, 리스트에 개의 문자열이 있다면:
    - 첫 번째 반복: 기존 문자열 복사(x), 새로운 문자열 추가(x) → 총2x
    - 두 번째 반복: 기존 문자열 복사(2x), 새로운 문자열 추가(x) → 총3x
    …
    - nn번째 반복: 기존 문자열 복사((n-1)x), 새로운 문자열 추가(x) → 총nx
- 총 작업량은 x+2x+3x+⋯+nx= $O(nx^2)$

**2. 효율적인 방법: `join()`**

파이썬에서는 문자열 연결 작업에 **`str.join()`** 메서드를 사용하는 것이 가장 효율적이다. `join()` 메서드는 리스트의 모든 문자열을 한 번에 연결하며, 내부적으로 필요한 메모리를 미리 할당해 복사 작업을 최소화한다.

- `join()`를 사용한 코드
    
    ```python
    def join_words(words):
        return "".join(words)
    ```
    
    - `join()`은 리스트 내 모든 문자열의 길이를 미리 계산하고, 필요한 메모리를 한 번에 할당한다.
    - 이후 문자열을 한 번의 작업으로 연결하므로 시간 복잡도는 O(nx) 가 된다.

파이썬에서 문자열 연결 작업이 많다면 `+=` 대신 `join()`을 사용하는 것이 성능 면에서 훨씬 효율적이다.

## 면접문제

---
참고로 저는 파이썬을 전공 수업으로 들어보았고, 파이썬 프로젝트 경험은 있지만, 자세한 문법을 기억하고 있지는 못한 상태입니다. 면접문제와 추후에 풀 leetcode 문제에서는 논리적 사고력을 키우는 것에 집중하고, 자잘한 문법은 간단하게 언급만 하고 넘어갑니다.

### 1.1 중복이 없는가

문자열이 주어졌을 때, 이 문자열에 같은 문자가 중복되어 등장하는지 확인하는 알고리즘을 작성해라. 

```python

### 내가 생각한 풀이
s = "123456asdfghas"
arr1 = []
for char in s:
    if char in arr1:
        print("같은 문자가 중복되어 등장합니다.")
        break
    arr1.append(char)
----------------------------------------------
### 집합을 사용한 gpt 풀이 
def has_duplicate(s):
    seen = set()
    for char in s:
        if char in seen:
            print("같은 문자가 중복되어 등장합니다.")
            return True
        seen.add(char)
    print("중복된 문자가 없습니다.")
    return False

s = "123456asdfghas"
has_duplicate(s)
------------------------------------------------
### 자료구조를 사용하지 않은 풀이
def has_duplicate2(s):
    for i in range(len(s)):
        for j in range(i + 1, len(s)):
            if s[i] == s[j]:
                print("같은 문자가 중복되어 등장합니다.")
                return True
    print("중복된 문자가 없습니다.")
    return False

s = "123456asdfghas"
has_duplicate2(s)
```

### 1.2 순열 확인

문자열 두개가 주어졌을 때 이 둘이 서로 순열 관계에 있는지 확인하는 메서드

** 순열 관계란 두 데이터가 같은 원소를 가지고 있지만 **원소의 순서만 다르다**는 것을 의미한다. 

예를들어 “abc”와 “cab”는 순열관계이다. 

```python
###내가 생각한 답 (오답임)
def permute(s1,s2):
    s1 = list(s1).sort()
    s2 = list(s2).sort()
    if len(s1)!=len(s2):
        print("문자열의 길이가 다릅니다.")
        return False
    if s1 == s2:
        print("순열 관계입니다")
        return True
-----------------------------------------------------------
### gpt 정답
def permute(s1, s2):
    if len(s1) != len(s2):
        print("문자열의 길이가 다릅니다.")
        return False
    
    s1_sorted = sorted(s1)
    s2_sorted = sorted(s2)
    
    if s1_sorted == s2_sorted:
        print("순열 관계입니다.")
        return True
    else:
        print("순열 관계가 아닙니다.")
        return False

s1 = "sba"
s2 = "abs"
print(permute(s1, s2))
```
> ❓
> <span style="color: #495057 ; font-weight: bold;">sort() vs sorted() </span>  
> 1. **`sort()`**
>   ```python
    numbers = [3, 1, 4, 1, 5, 9]
    sorted_numbers = sorted(numbers)  # 정렬된 새로운 리스트를 반환
    print(numbers)  # 원본 리스트는 변경되지 않음: [3, 1, 4, 1, 5, 9]
    print(sorted_numbers)  # 출력: [1, 1, 3, 4, 5, 9]
    ```
> - key와 reverse 인자를 통해 정렬 방식을 변경할 수 있다.
> - 리스트, 문자열, 튜플, 딕셔너리 등 이터러블(iterable)한 모든 객체에 사용할 수 있다.
> - `sorted()`는 파이썬의 내장 함수로, 입력 데이터를 변경하지 않고 **정렬된 새로운 리스트**를 반환한다. 따라서 원본 데이터는 그대로 유지된다.
> 2. **`sorted()`**
>   ```python
    numbers = [3, 1, 4, 1, 5, 9]
    numbers.sort()  # 리스트를 제자리에서 정렬
    print(numbers)  # 출력: [1, 1, 3, 4, 5, 9]
    ```
> - 디폴트는 오름차순 정렬이고, `key`와 `reverse` 인자를 통해 정렬 방식을 변경할 수 있다.
> - `sort()`는 리스트의 메서드로, 리스트를 **제자리에서(in-place)** 정렬한다. 즉, 리스트 자체가 변경되며 별도의 정렬된 리스트를 반환하지 않는다. 리스트에서만 사용가능하다.


### 1.3 URL화

문자열에 들어있는 모든 공백을 ‘%20’으로 바꿔주는 메서드를 작성하라.

```python
s = "dltpqls dms q123"
### 내풀이 1
url = s.replace(" ","%20")
print(url)

### 내풀이 2
def to_url(s):
    url2 = []
    for char in s:
        if char == " ":
            url2.append("%20")
        else :
            url2.append(char)
    print(''.join(url2))
to_url(s)
```

### 1.4 회문 순열

주어진 문자열이 회문(palindrome)의 순열인지 아닌지 확인하는 함수를 작성하라.

*회문이란 앞으로읽으나 뒤로읽으나 같은 단어 또는 구절을 의미함.

*회문 순열이란 주어진 문자열의 문자들을 재배열했을 때 회문을 만들 수 있다면 **회문 순열**에 해당

```python
### 내풀이 (오답) 
# 이건 회문만을 확인하는 코드임.
def palindrome(s):
    s = s.lower()  
    s = s.replace(" ", "") 
    for i in range(len(s)):
        if s[i] != s[len(s) - 1 - i]:
            return False
    return True  

s = "A man a plan a canal Panama"
print(palindrome(s))

### gpt 정답
def is_palindrome_permutation(s):
    s = s.lower().replace(" ", "")
    
    char_count = {} # 각 문자의 개수를 저장할 딕셔너리 생성
    
    for char in s:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1

    odd_count = 0
    for count in char_count.values():
        if count % 2 == 1:
            odd_count += 1
            # 홀수 개수가 1개를 초과하면 회문 순열이 될 수 없음
            if odd_count > 1:
                return False
                
    return True
```

><span style="color: #495057 ; font-weight: bold;"> ✅self feedback</span>   
>1.4 회문 순열 문제는 회문 순열에 대해 개념적으로 이해하지 못해서 회문만을 확인하는 코드를 짰다. 출력 예시를 잘 보고 문제를 먼저 잘 이해하자. 

- 개념정리부터 4문제 풀이하는 것까지 3시간 소요됐습니다. <내풀이>는 gpt의 도움을 받지 않고 푸는 것이고, 가끔 헷갈리는 문법은 점프투파이썬을 참고했을 때의 풀이입니다.  